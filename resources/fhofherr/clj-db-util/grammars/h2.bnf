(*
 * H2 Datatabase SQL grammar with slight modifications.
 *
 * Based on the official H2 grammar from the H2 website
 * http://www.h2database.com/html/grammar.html
 *)

S ::= DML <#"\s*;\s*">?;

DML ::= SELECT-STMT;

SELECT-STMT ::= SELECT (DISTINCT | ALL)? SELECT-EXPR+
                FROM TABLE-EXPR+
                (WHERE EXPR)?;

SELECT-EXPR ::= '*' | TABLE-ALIAS '.*' | EXPR (AS? COLUMN-ALIAS)?;

TABLE-EXPR ::= ((SCHEMA-NAME '.')? TABLE-NAME | '(' SELECT-STMT ')')
               (AS? TABLE-ALIAS)?;

TABLE-ALIAS ::= ALIAS

COLUMN-ALIAS ::= ALIAS;

COLUMN-NAME ::= NAME;

SCHEMA-NAME ::= NAME;

TABLE-NAME ::= NAME;

SEQUENCE-NAME ::= NAME;

<EXPR> ::= AND-CONDITION (OR AND-CONDITION)?;

<AND-CONDITION> ::= CONDITION (AND CONDITION)?;

<CONDITION> ::= OPERAND CONDITION-RIGHT-HAND-SIDE? |
                NOT CONDITION |
                EXISTS "(" SELECT-STMT ")";

<CONDITION-RIGHT-HAND-SIDE> ::=
    (COMPARE (((ALL | ANY | SOME) <"("> SELECT-STMT <")">) | OPERAND)) |
    IS NOT NULL |
    IS NOT? DISTINCT-FROM? OPERAND |
    BETWEEN OPERAND AND OPERAND |
    IN ("(" SELECT-STMT ")" | EXPR+) |
    NOT? LIKE OPERAND (ESCAPE STRING)? |
    NOT? REGEXP OPERAND;

<OPERAND> ::= (SUMMAND (CONCAT SUMMAND)*) | NAMED-PARAM | PARAM;

<SUMMAND> ::= FACTOR (('+' | '-') FACTOR)*;

<FACTOR> ::= TERM (('*' | '/' | '%') TERM)*;

<TERM> ::= VALUE |
           COLUMN-NAME |
           '?' INTEGRAL-NUMBER |
           NEXT-VALUE-FOR SEQUENCE-NAME |
           (* FUNCTION | *)
           ('-' | '+') TERM |
           '(' EXPR ')' |
           SELECT-STMT |
           CASE-STMT |
           CASE-WHEN-STMT |
           TABLE-ALIAS '.' COLUMN-NAME

<VALUE> ::= STRING |
            DOLLAR-QUOTED-STRING |
            NUMERIC |
            DATE |
            TIME |
            TIMESTAMP |
            BOOLEAN |
            BYTES |
            ARRAY |
            NULL;

BYTES ::= "X" "'" HEX "'";

<COMPARE> ::= NEQ | LEQ | GEQ | EQ | LT | GT | OVERLAPPING

ALIAS ::= NAME;

(* H2 Database allows user-defined functions. Nevertheless the official H2
 * grammar lists all the functions allowed.
 *
 * TODO: does this mean one can not use user-defined functions where
 *       FUNCTION is expected?
 *)
FUNCTION ::= "";

CASE-STMT ::= CASE EXPR
              (WHEN EXPR THEN EXPR)+
              (ELSE EXPR)?
              END;

CASE-WHEN-STMT ::= CASE
                   (WHEN EXPR THEN EXPR)+
                   (ELSE EXPR)?
                   END;

BOOLEAN ::= TRUE | FALSE

STRING ::= <"\'"> #'([^\']|\'\')+'? <"\'">;

DOLLAR-QUOTED-STRING ::= <"$$">
                        ("$" |
                         #"[^\$]+" |
                         #"\$[^\$]+" |
                         #"[^\$]+\$" |
                         #"[^\$]+\$[^\$]+")?
                        <"$$">

<NUMERIC> ::= INTEGRAL-NUMBER | DECIMAL-NUMBER | HEX-NUMBER;

INTEGRAL-NUMBER ::= ('+' | '-')? NUMBER;

(* NOTE: To avoid ambiguities with INTEGRAL-NUMBER the rule
 *
 *       ('+' | '-')? NUMBER
 *
 * is deliberately left out.
 *)
DECIMAL-NUMBER ::= ('+' | '-')?
                   ((NUMBER "." NUMBER) | ("." NUMBER))
                   ('E' ('+' | '-')? NUMBER)?;

<NUMBER> ::= #'[0-9]+'

HEX-NUMBER ::= ('+' | '-')? <'0x'> HEX

HEX ::= #'[0-9a-fA-F]{2}'+

(* TODO: consider introducing the rules YEAR, MONTH, DAY *)
DATE ::= <#'(?i)date\s+'> <"\'"> #'\d{4}-\d{2}-\d{2}' <"\'">;

(* TODO: consider introducing the rules HOUR, MINUTE, SECOND *)
TIME ::= <#'(?i)time\s+'> <"\'"> #'\d{2}:\d{2}:\d{2}' <"\'">;

TIMESTAMP ::= <#'(?i)timestamp\s+'> <"\'"> #'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(.\d{1,9})?' <"\'">;

<NAME> ::= (#"(?i)[A-Z_][A-Z0-9_]*" | QUOTED-NAME);

<QUOTED-NAME> ::= '\"' #'([^\"]|\"\")+' '\"'

ARRAY ::= <"("> ((EXPR <#',\s*'>) (EXPR | (EXPR <#',\s*'>))*)? <")">

(* Tokens *)

ALL            ::= <#'(?i)\s*all\s*'>;
AND            ::= <#'(?i)\s*and\s*'>;
ANY            ::= <#'(?i)\s*any\s*'>;
AS             ::= <#'(?i)\s*as\s*'>;
BETWEEN        ::= <#'(?i)\s*between\s*'>;
CASE           ::= <#'(?i)\s*case\s*'>;
CONCAT         ::= <#'\s*\|\|\s*'>;
DISTINCT-FROM  ::= <#'(?i)\s*distinct\s+from\s*'>;
DISTINCT       ::= <#'(?i)\s*distinct\s*'>;
ELSE           ::= <#'(?i)\s*else\s*'>;
END            ::= <#'(?i)\s*end\s*'>;
EQ             ::= <#'\s*=\s*'>;
ESCAPE         ::= <#'(?i)\s*escape\s*'>;
EXISTS         ::= <#'(?i)\s*exists\s*'>;
FALSE          ::= <#'(?i)\s*false\s*'>;
FROM           ::= <#'(?i)\s*from\s*'>;
GEQ            ::= <#'\s*>=\s*'>;
GT             ::= <#'\s*>\s*'>;
IN             ::= <#'(?i)\s*in\s*'>;
IS             ::= <#'(?i)\s*is\s*'>;
LEQ            ::= <#'\s*<=\s*'>;
LIKE           ::= <#'(?i)\s*like\s*'>;
LT             ::= <#'\s*<\s*'>;
NEQ            ::= <#'\s*<>\s*'> | <#'\s*!=\s*'>;
NEXT-VALUE-FOR ::= <#'(?i)\s*next\s+value\s+for\s*'>;
NOT            ::= <#'(?i)\s*not\s*'>;
NULL           ::= <#'(?i)\s*null\s*'>;
OR             ::= <#'(?i)\s*or\s*'>;
OVERLAPPING    ::= <#'\s*&&\s*'>;
REGEXP         ::= <#'(?i)\s*regexp\s*'>;
SELECT         ::= <#'(?i)\s*select\s*'>;
SOME           ::= <#'(?i)\s*some\s*'>;
THEN           ::= <#'(?i)\s*then\s*'>;
TRUE           ::= <#'(?i)\s*true\s*'>;
WHEN           ::= <#'(?i)\s*when\s*'>;
WHERE          ::= <#'(?i)\s*where\s*'>;

(* Extension: named parameters *)

PARAM ::= <"?">
NAMED-PARAM ::= <":"> #"(?i)[A-Z_][A-Z0-9_-]*";
